<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anaconda Instructions</title>
    <url>/2023/02/02/Anaconda-Instructions/</url>
    <content><![CDATA[<p>Conda is an open-source package and environment management system that runs on Windows, macOS, and Linux. Conda quickly installs, runs, and updates packages and their dependencies. It also easily creates, saves, loads, and switches between environments on your local computer. It was created for Python programs, but it can package and distribute software for any language.</p>
<span id="more"></span>

<h1 id="Anaconda-Instructions"><a href="#Anaconda-Instructions" class="headerlink" title="Anaconda Instructions"></a>Anaconda Instructions</h1><h2 id="Configure-your-environment-with-‘conda’"><a href="#Configure-your-environment-with-‘conda’" class="headerlink" title="Configure your environment with ‘conda’"></a>Configure your environment with ‘conda’</h2><h3 id="Create-a-new-environment"><a href="#Create-a-new-environment" class="headerlink" title="Create a new environment"></a>Create a new environment</h3><ol>
<li>Create an environment without additional packages.</li>
</ol>
<pre><code class="bash">conda create -n &lt;env_name&gt;
</code></pre>
<ol start="2">
<li>An environment with additional packages.</li>
</ol>
<pre><code class="bash">conda create -n &lt;env_name&gt; &lt;package_1&gt; &lt;package_2&gt;
</code></pre>
<h3 id="Activate-x2F-Deactivate-the-new-environment"><a href="#Activate-x2F-Deactivate-the-new-environment" class="headerlink" title="Activate&#x2F;Deactivate the new environment"></a>Activate&#x2F;Deactivate the new environment</h3><ol>
<li>Activate</li>
</ol>
<pre><code class="bash">conda activate &lt;env_name&gt;
</code></pre>
<ol start="2">
<li>Install many packages with a single line</li>
</ol>
<pre><code class="bash">conda install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt; ...
</code></pre>
<ol start="2">
<li>Deactivate</li>
</ol>
<pre><code class="bash">conda deactivate
</code></pre>
<h2 id="View-information"><a href="#View-information" class="headerlink" title="View information"></a>View information</h2><ol>
<li>Show environments information</li>
</ol>
<pre><code class="bash">conda env list
</code></pre>
<ol start="2">
<li>Show a list of packages in the environment</li>
</ol>
<pre><code>conda list
</code></pre>
<h2 id="Rename-a-environment"><a href="#Rename-a-environment" class="headerlink" title="Rename a environment"></a>Rename a environment</h2><ol>
<li>Clone the old environment</li>
</ol>
<pre><code class="bash">conda create -n &lt;new_env&gt; --clone &lt;old_env&gt;
</code></pre>
<ol start="2">
<li>Remove the old environment</li>
</ol>
<pre><code class="bash">conda remove -n &lt;old_name&gt; --all
</code></pre>
<h2 id="Share-environment"><a href="#Share-environment" class="headerlink" title="Share environment"></a>Share environment</h2><ol>
<li>Export existent environment</li>
</ol>
<pre><code class="bash">conda env export &gt; &lt;default.yml&gt;
</code></pre>
<ol start="2">
<li>Recreate a new environment</li>
</ol>
<pre><code class="bash">conda env create -f &lt;default.yml&gt; -n &lt;env_name&gt;
</code></pre>
]]></content>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Subsystem for Linux (WSL)</title>
    <url>/2023/02/02/Windows-Subsystem-for-Linux-WSL/</url>
    <content><![CDATA[<p>The Windows Subsystem for Linux provides developers a platform to run a GNU&#x2F;Linux environment directly on Windows, including most command-line tools, utilities, and applications, without the overhead of a traditional virtual machine or dualboot setup.</p>
<span id="more"></span>

<h1 id="Windows-Subsystem-for-Linux-WSL"><a href="#Windows-Subsystem-for-Linux-WSL" class="headerlink" title="Windows Subsystem for Linux (WSL)"></a>Windows Subsystem for Linux (WSL)</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="What-is-WSL"><a href="#What-is-WSL" class="headerlink" title="What is WSL?"></a>What is WSL?</h3><p>The <strong>Windows Subsystem for Linux</strong> provides developers a platform to run a <strong>GNU&#x2F;Linux environment</strong> directly on Windows, including most command-line tools, utilities, and applications, <strong>without</strong> the overhead of a traditional <strong>virtual machine</strong> or <strong>dualboot setup</strong>.</p>
<ul>
<li><p>Invoke Windows application using a Unix-like command-line shell.</p>
</li>
<li><p>Invoke GNU&#x2F;Linux application on Windows.</p>
</li>
<li><p>Run GNU&#x2F;Linux graphical application integrated directly to your Windows desktop.</p>
</li>
<li><p>Use GPU acceleration for machine learning, data science scenarios and more.</p>
</li>
</ul>
<h3 id="Comparing-WSL-versions"><a href="#Comparing-WSL-versions" class="headerlink" title="Comparing WSL versions"></a>Comparing WSL versions</h3><p>WSL 2 is a new version of the WSL architecture that powers the WSL to run ELF64 Linux binaries on Windows. Its primary goals are to <strong>increase file system performance</strong>, as well as <strong>adding full system call compatibility</strong>. This new architecture changes how these Linux binaries interact with Windows and computer’s hardware, benefiting from running a real Linux kernel.</p>
<p>The primary differences between WSL 1 and WSL 2 are the use of an actual Linux kernel inside a managed VM, support for full system call compatibility, and performance across the Linux and Windows operating system.</p>
<p><img src="/2023/02/02/Windows-Subsystem-for-Linux-WSL/image-20230119141625312.png" alt="image-20230119141625312"></p>
<blockquote>
<h4 id="WSL-2-Architecture"><a href="#WSL-2-Architecture" class="headerlink" title="WSL 2 Architecture"></a><strong>WSL 2 Architecture</strong></h4><p>A traditional VM experience can be slow to boot up, is isolated, consumes a lot of resources, and requires your time to manage it. However, WSL 2 provides the benefits of WSL 1, including seamless integration between Windows and Linux, fast boot time, small resource consumption, and requires no VM configuration or management. While <strong>WSL 2 does use a VM</strong>, it is managed and run behind the scenes, leaving you with the same user experiences WSL 1.</p>
<h4 id="Full-Linux-Kernel"><a href="#Full-Linux-Kernel" class="headerlink" title="Full Linux Kernel"></a><strong>Full Linux Kernel</strong></h4><p>The Linux kernel in WSL 2 is built by Microsoft from the latest stable branch, based on the source available at kernel.org. This kernel has been specially tuned for WSL 2, optimizing for <strong>size and performance</strong> to provide an amazing Linux experience on Windows.</p>
<h4 id="Increased-file-IO-performance"><a href="#Increased-file-IO-performance" class="headerlink" title="Increased file IO performance"></a><strong>Increased file IO performance</strong></h4><p>File intensive operations like git clone, npm install, apt update, and more are all noticeably faster with WSL 2. The actual speed increase will depend on which ap you’re running and how it is interacting with the file system.</p>
<h4 id="Full-system-call-compatibility"><a href="#Full-system-call-compatibility" class="headerlink" title="Full system call compatibility"></a><strong>Full system call compatibility</strong></h4><p>Linux binaries use system calls to perform functions such as accessing file, requesting memory, creating processes, and more. Whereas WSL 1 used a translation layer that was built by the WSL team, <strong>WSL 2 includes its own Linux kernel with full system call compatibility</strong>. </p>
</blockquote>
<h3 id="Basic-wsl-commands"><a href="#Basic-wsl-commands" class="headerlink" title="Basic wsl commands"></a>Basic wsl commands</h3><pre><code class="shell">wsl --help
</code></pre>
<h3 id="Get-started-with-Git"><a href="#Get-started-with-Git" class="headerlink" title="Get started with Git"></a>Get started with Git</h3><ol>
<li><p><strong>Git Credential Manager setup</strong></p>
<p>GCM is a secure GIt credential helper built on .NET that can be used with both WSL 1 and WSL 2. It enables multi-factor authentication support for GitHub repos, Azure DevOps, Azure DevOps Server, and Bitbucket. Once you’re authenticated to your hosting provider, requests a new authentication token, It then <strong>stores the token in the GCM</strong>. After the first time, you can use GIt to talk to your hosting provider without needing to re-authenticate.</p>
</li>
</ol>
<pre><code class="bash"># if GIt installed is &gt;= v2.36.1
git config --global credential.helper &quot;/mnt/c/Program\ Files/Git/mingw64/bin/git-credential-manager-core.exe&quot;
# else if version is &lt; v2.36.1 enter this command:
git config --global credential.helper &quot;/mnt/c/Program\ Files/Git/mingw64/libexec/git-core/git-credential-manager.exe&quot;
</code></pre>
<blockquote>
<h4 id="Proxy-settings-are-unique-to-the-specific-WSL-installation-and-not-shared-with-others-or-the-Windows-host"><a href="#Proxy-settings-are-unique-to-the-specific-WSL-installation-and-not-shared-with-others-or-the-Windows-host" class="headerlink" title="Proxy settings are unique to the specific WSL installation and not shared with others or the Windows host."></a>Proxy settings are unique to the specific WSL installation and not shared with others or the Windows host.</h4></blockquote>
<ol start="2">
<li><p><strong>Connect to GitHub with Secure Shell Protocol (SSH)</strong></p>
<ol>
<li><p><strong>About SSH.</strong> With SSH protocol, you can connect and authenticate to remote servers and services. With SSH keys, you do not need to provide your username and personal access token at each visit. You can also use an SSH key to sign commits. When you set up SSH, you will need to generate <strong>a new private SSH key</strong> and add it to the SSH agent. You must also add <strong>the public SSH key</strong> to your account on GitHub before you use the key to authenticate or sign commits.</p>
</li>
<li><p><strong>Checking for existing SSH keys.</strong> Before you generate a new SSH key, you should check your local machine for existing keys. Just Enter <code>ls -al ~/.ssh</code> to see if existing any SSH key at present. If you see an existing public and private key pair listed, you would like to use to connect to GitHub, and add the key to the ssh-agent.</p>
</li>
<li><p><strong>Generating a new SSH key and adding it to the ssh-agent.</strong> You can generate a new SSH key on your local machine. After you generate the key, you can add the key to your account on GitHub.com to enable authentication for GIt operations over SSH. Paste <code>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code> then create a new SSH key. If you don’t have extra requirements (specific file location or passphrase, etc.), press Enter to the end.</p>
<p>Before adding a new SSH key to the ssh-agent to manage your keys, you should have checked for existing SSH keys and generated a new SSH key. First, ensure the ssh-agent is running. <code>eval &quot;$(ssh-agent -s)&quot;</code> Second, add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace <em>id_ed25519</em> in the command with the name of your private key file. Finally, add the SSH key to your account on GitHub.</p>
<p><strong>If you are using macOS or Linux,</strong> you may need to update your SSH client or install a new SSH client prior to generating a new SSH key.</p>
</li>
<li><p><strong>Adding a new SSH key to your GitHub account.</strong> After you generate an SSH key pair, you must add the public key to GitHUb.com to enable SSH access for your account.</p>
</li>
<li><p><strong>Testing your SSH connection.</strong> </p>
</li>
<li><p><strong>Working with SSH key passphrases.</strong> You can secure your SSH keys configure an authentication agent so that you won’t have to reenter your passphrases every time your use your SSH keys.</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake Tools for VS Code Documentation</title>
    <url>/2023/02/02/CMake-Tools-for-VS-Code-Documentation/</url>
    <content><![CDATA[<p>CMake is an open-source, cross-platform tool that uses complier and platform independent configuration files to generate native build tool files specific to your complier and platform. And the CMake tools extension integrates VS Code and CMake to make it easier to configure, build and debug your C++ project.</p>
<span id="more"></span>

<h1 id="CMake-Tools-for-VS-Code-Documentation"><a href="#CMake-Tools-for-VS-Code-Documentation" class="headerlink" title="CMake Tools for VS Code Documentation"></a>CMake Tools for VS Code Documentation</h1><h2 id="Get-started-with-CMake-Tools-on-Linux"><a href="#Get-started-with-CMake-Tools-on-Linux" class="headerlink" title="Get started with CMake Tools on Linux"></a>Get started with CMake Tools on Linux</h2><p>CMake is an open-source, cross-platform tool that uses complier and platform independent configuration files to generate native build tool files specific to your complier and platform. And the CMake tools extension integrates VS Code and CMake to make it easier to configure, build and debug your C++ project.</p>
<ol>
<li><strong>Check your environment.</strong></li>
</ol>
<p>Although you’ll use VS Code to edit your source code, you’ll compile, debug the source code using complier and debugger, and build tools installed in your system. Check your environment to ensure your GCC, GDB and CMake installed, as well as CMake Tools on VS Code.</p>
<ol start="2">
<li><strong>Create CMakeLists.txt</strong></li>
</ol>
<p>CmakeLists.txt would tell the CMake tools how to builds your project, which contains a set of directives and instructions describing the project’s source files and targets (executable, library or both).</p>
<ol start="3">
<li><strong>Select a kit</strong></li>
</ol>
<p>Before you can access to use CMake Tools to organize your project, you have to configure the extension know about the compliers on your system. A kit represents a toolchain, which is the compiler, linker and other tools used to build your project.</p>
<ol start="4">
<li><strong>Select a variant</strong></li>
</ol>
<p>A variant contains instructions for how to build your project. By default, the CMake Tools extension provides four variants, each corresponding to a default build type: Debug, Release, MinRelSize, and RelWithDebInfor. These options do the following:</p>
<p><strong>Debug</strong>: disables optimizations and includes debug information. <strong>Release</strong>: Includes optimizations but no debug information. <strong>MinRelSize</strong>: Optimizes for size. No debug information. <strong>RelWithDebInfo</strong>: Optimizes for speed and includes debug info.</p>
<ol start="5">
<li><strong>CMake: Configure &amp; Build</strong></li>
</ol>
<p>Run the <strong>CMake: Configure</strong> command to configure your project. This generates build files in the project’s build folder using the kit and variant you selected. After configuring your project, then just click the Build button of the status bar at the right-below corner.</p>
<h2 id="The-CMake-configure-proces"><a href="#The-CMake-configure-proces" class="headerlink" title="The CMake configure proces"></a>The CMake configure proces</h2><p>In CMake, <em>Configure</em> refers to detecting requirements and generating the build files that will produce the final complicated artifacts. The following concepts will help you to understand how CMake Tools interacts with Cmake’s confugure process.</p>
<ul>
<li>The CMake Cache is a list of key-value pairs that persist between runs of the configure process.</li>
<li>Cache initializer arguments are the arguments passed to CMake that set values in the cache before any CMake scripts are run.  These allow you to control the build settings.</li>
<li>Unless overwritten or deleted, values in the CMake Cache persist between CMake runs.</li>
<li>CMake doesn’t do the build itself, it relies on build tools installed on your system. The result of a <em>configure</em> depends on the CMake Generator. The Generator tells CMake what kind of tool will be used to compile and generate the results of the build. Here are several families of generators availabel.</li>
</ul>
<table>
<thead>
<tr>
<th>Generator</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Ninja</td>
<td>Emits files for Ninja Build Tools. This is the default generator that CMake Tools uses, unless configured otherwise.</td>
</tr>
<tr>
<td>Makefile</td>
<td>Emits a Makefile for the project that can be built via <code>make</code></td>
</tr>
<tr>
<td>Visual Studio</td>
<td>Emits visual studio solutions and project files. There are many different Visual Studio generators, so it is recommended to let CMake Tools automatically determine the appropriate generator.</td>
</tr>
</tbody></table>
<h2 id="The-Cmake-Tools-configure-step"><a href="#The-Cmake-Tools-configure-step" class="headerlink" title="The Cmake Tools configure step"></a>The Cmake Tools configure step</h2><ol>
<li>The activate kit. CMake kits provide information about toolchains available on your system that can be used with CMake to build your project.</li>
<li>Which generator to use. CMake doesn’t deal the build process itself, instead it requires specific generator (the default option is Nanja on VS Code) to do the work. </li>
<li>The configuration options.  CMake Tools has a variety of locations where configuration options can be define.</li>
<li>The configuration environment. CMake Tools sets environment variables for the child process it runs for CMake.</li>
</ol>
<h2 id="Build-with-CMake-Tools"><a href="#Build-with-CMake-Tools" class="headerlink" title="Build with CMake Tools"></a>Build with CMake Tools</h2><p>Once you have configured your project, then you can start to run a CMake build. Most of your time with CMake Tools will be spend in the process of configuring the build. You can just click the <code>build</code> button in the VS Code status bar. Starting a new build while an existing build is running will cancel the current build and start a new one.</p>
<h3 id="Build-the-target"><a href="#Build-the-target" class="headerlink" title="Build the target"></a>Build the target</h3><p>CMake Tools persists a “default target” for the build process. The default target is the “all” target, which builds all of the targets that CMake has designated for a default build.</p>
<p><img src="https://github.com/microsoft/vscode-cmake-tools/raw/main/docs/images/default_target.png" alt="Default target as shown in the status bar"></p>
<p>Also, you can build a single target without changing the current build target from the VS Code by running the <code>CMake: Build a target</code> command. CMake will build any dependent targets, even if they aren’t directly selected.</p>
]]></content>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
</search>
